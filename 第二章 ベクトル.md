## 2.5 all()和 any()的使用
### 2.5.1 例子：寻找连续值
寻找由0，1组成的数列里，1的连续数列。
比方说在向量c(1,0,0,1,1,1,0,1,1)里，序列4开始连续序列长度为3，序列4，5，8，开始的话连续数列长度为2。  
编写一个函数``findruns()``,使得``findruns(c(1,0,0,1,1,1,0,1,1),2)``会返回有连续k个1的起始点的位置的数列(4,5,8)

```r
findruns<-function(x,k){
  n<-length(x) #数列x的长度
  runs<- NULL  #新建runs(最后返回的结果)
  for(i in 1:(n-k+1)){ #在1：(n-k+1)中的值里，
    if(all(x[i:(i+k-1)]==1)) runs<-c(runs,i) #从i位起，连续k位取值为1的话，runs就赋值为i，起始的NULL会被自动省略。
  }
  return(runs) #结果返回runs
}
```

x[i]から始まるすべてのk個の値、つまりx[i],x[i+1],...x[i+k-1]のすべての値が1であるかを判別する。　　
如果在这个范围里面的x值都是1，那么就显示runs，  
``runs<-NULL``  
``runs<-c(runs,i)``

还有一种更加节省计算速度的方法
```r
findruns1<-function(x,k){
  n<-length(x)
  runs<-vector(length=n) #把runs设置成长度为n的向量
  count<-0 #新增count，起始值为0
  for(i in 1:(n-k+1)){ #在1：(n-k+1)中的值里
    if (all(x[i:(i+k-1)]==1)){ #从i位起，连续k位取值为1的话,
      count<-count+1 #count就+1,
      runs[count]<-i #给第count位的runs值赋值，值位i。
    }
  }
  if(count>0){  #如果count大于0，
    runs<-runs[1:count] #就取1到count位的runs值
  } else runs<-NULL #否则就取NULL值
  return(runs) #结果返回runs
}
```
- 第一个for循环给所有的runs赋值，第二个if循环，提取了不是NULL的值  
- 最大的不同就是提前定义了向量runs，预留了内存空间。不用一次一次的读取内存。  

首先在``runs<-vector(length=n)`` 中设定了runs, 然后``runs[count]<-i``给runs赋值，
最后``runs<-runs[1:count]``再定义了runs，删除了不需要的信息。这个function只提取了两次内存。

### 2.5.2 应用题：离散值的时间序列预测
根据最近的降雨情况来预测明天的降雨。最近k天，降雨为1，不降雨为0。k天的1的次数不少于k/2的时候，则预测第二天会下雨，即1，除此以外为不下雨，即0。
然后对每天的预测值和实测值进行对比。求误差的平均值，来求最佳的k值。

```r
preda<-function(x,k){
  n<-legnth(x)
  k2<-k/2
  pred<-vector(length=n-k)
  for(i in 1:(n-k)){
    if(sum(x[i:(i+(k-1))])>=k2) pred[i]<-1 else pred[i]<-0
  }
  return(mean(abs(pred-x[(k+1):n])))
}
```
