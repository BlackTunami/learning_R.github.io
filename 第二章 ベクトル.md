## 2.5 all()和 any()的使用
### 2.5.1 例子：寻找连续值
寻找由0，1组成的数列里，1的连续数列。
比方说在向量c(1,0,0,1,1,1,0,1,1)里，序列4开始连续序列长度为3，序列4，5，8，开始的话连续数列长度为2。  
编写一个函数``findruns()``,使得``findruns(c(1,0,0,1,1,1,0,1,1),2)``会返回数字(4,5,8)

```r
findruns<-function(x,k){
  n<-length(x)
  runs<- NULL
  for(i in 1:(n-k+1)){
    if(all(x[i:(i+k-1)]==1)) runs<-c(runs,i)
  }
  return(runs)
}
```
x[i]から始まるすべてのk個の値、つまりx[i],x[i+1],...x[i+k-1]のすべての値が1であるかを判別する。　　
如果在这个范围里面的x值都是1，那么就显示runs，  
``runs<-NULL``  
``runs<-c(runs,i)``

还有一种更加节省计算速度的方法
```r
findruns1<-function(x,k){
  n<-length(x)
  runs<-vector(length=n)
  count<-0
  for(i in 1:(n-k+1)){
    if (all(x[i:(i+k-1)]==1)){
      count<-count+1
      runs[count]<-i
    }
  }
  if(count>0){
    runs<-runs[1:count]
  } else runs<-NULL
  return(runs)
}
```
-  最大的不同就是提前定义了runs，预留了内存空间。不用一次一次的读取内存。

首先在``runs<-vector(length=n)`` 中设定了runs, 然后``runs[count]<-i``给runs赋值，
最后``runs<-runs[1:count]``再定义了runs，删除了不需要的信息。这个function只提取了两次内存。

### 2.5.2 应用题：离散值的时间序列预测
根据最近的降雨情况来预测明天的降雨。最近k天，降雨为1，不降雨为0。k天的1的次数不少于k/2的时候，则预测第二天会下雨，即1，除此以外为不下雨，即0。
然后对每天的预测值和实测值进行对比。求误差的平均值，来求最佳的k值。

```r
preda<-function(x,k){
  n<-legnth(x)
  k2<-k/2
  pred<-vector(length=n-k)
  for(i in 1:(n-k)){
    if(sum(x[i:(i+(k-1))])>=k2) pred[i]<-1 else pred[i]<-0
  }
  return(mean(abs(pred-x[(k+1):n])))
}
```
